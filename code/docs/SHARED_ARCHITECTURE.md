# LSE Shared CLUT Architecture

## Overview

This implementation realizes the shared CLUT (Correction Look-Up Table) architecture described in Yao et al., "LSE-PE: Hardware Efficient for Tractable Probabilistic Reasoning". The key innovation is **resource sharing**: multiple LSE processing elements (LSE-PE) share a single CLUT to reduce hardware area while maintaining computational throughput.

## Architecture Principles

### Shared CLUT Design

According to the research paper:

> "In this configuration, multiple units share access to the same CLUT, but each LSE-PE unit is equipped with its own multiplexer (MUX) to select 10 bits for error correction."

This design provides:
- **Hardware Efficiency**: Single CLUT instead of N separate CLUTs for N processing elements
- **Maintained Performance**: Each PE has independent MUX for parallel address generation
- **Scalable Architecture**: Easy to configure for different numbers of PEs

### System Components

```
┌──────────────────────────────────────────────────────┐
│                LSE Shared System                     │
│                                                      │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐         │
│  │  MAC 0    │  │  MAC 1    │  │  MAC N    │         │
│  │ ┌──────┐  │  │ ┌──────┐  │  │ ┌──────┐  │         │
│  │ │ MULT │  │  │ │ MULT │  │  │ │ MULT │  │         │
│  │ └───┬──┘  │  │ └───┬──┘  │  │ └───┬──┘  │         │
│  │  ┌──▼───┐ │  │  ┌──▼───┐ │  │  ┌──▼───┐ │         │
│  │  │LSE-PE│ │  │  │LSE-PE│ │  │  │LSE-PE│ │         │
│  │  │ +MUX │ │  │  │ +MUX │ │  │  │ +MUX │ │         │
│  │  └───┬──┘ │  │  └───┬──┘ │  │  └───┬──┘ │         │
│  └──────┼────┘  └──────┼────┘  └──────┼────┘         │
│         │              │              │              │
│         └──────────────┴──────────────┘              │
│                        │                             │
│                 ┌──────▼──────┐                      │
│                 │ Arbitration │                      │
│                 └──────┬──────┘                      │
│                        │                             │
│                 ┌──────▼──────┐                      │
│                 │ Shared CLUT │                      │
│                 │ (16 entries)│                      │
│                 └─────────────┘                      │
└──────────────────────────────────────────────────────┘
```

## Module Hierarchy

### 1. `lse_log_mac.sv` - Log Multiply-Accumulate Unit

Implements: **result = LSE(accumulator, log_a + log_b)**

**Features:**
- Log-domain multiplication (addition in log space)
- Accumulator management
- Integrated LSE-PE unit
- Bypass mode for addition-only operations

**Key Parameters:**
- `WIDTH = 24`: Data path width
- `MAC_ID`: Unique identifier for debugging

**Interfaces:**
- Input: `log_a`, `log_b`, `accumulator`
- Output: `mac_result`, `valid_out`
- CLUT Interface: `clut_address`, `clut_correction`, `clut_valid`, `clut_ready`

### 2. `lse_pe_with_mux.sv` - LSE Processing Element with MUX

Implements the core LSE addition with integrated multiplexer for CLUT addressing.

**Pipeline Stages:**
1. **Stage 1**: Compute max, delta, extract fractional bits
2. **Stage 2**: MUX generates CLUT address from fractional bits
3. **Stage 3**: Apply CLUT correction to max value

**Features:**
- 2-stage pipeline for timing optimization
- 10-bit fractional extraction for CLUT indexing
- 4-bit address generation (16 CLUT entries)
- Automatic CLUT request generation

**Key Parameters:**
- `WIDTH = 24`: Total bit width
- `FRAC_BITS = 10`: Fractional bits for precision

### 3. `lse_clut_shared.sv` - Shared CLUT with Multi-Port Access

Shared look-up table accessible by multiple processing elements.

**Features:**
- Multi-port read access (configurable `NUM_PE`)
- Single ROM instance shared across all ports
- Synchronous read operation
- Python-generated correction values

**ROM Content:**
The CLUT stores correction values for: **log(1 + exp(-Δ))**

Values are automatically generated by `generate_clut_values.py` and inserted between:
```systemverilog
// === PYTHON SCRIPT START: AUTO-GENERATED CLUT VALUES ===
// ... ROM data here ...
// === PYTHON SCRIPT END: AUTO-GENERATED CLUT VALUES ===
```

**Key Parameters:**
- `NUM_PE = 4`: Number of processing elements
- `ADDR_WIDTH = 4`: 16 entries (2^4)
- `DATA_WIDTH = 10`: Correction value width

### 4. `lse_shared_system.sv` - Top-Level System Integration

Complete system integrating multiple MAC units with shared CLUT.

**Features:**
- Configurable number of MAC units (`NUM_MAC_UNITS = 4`)
- Round-robin arbitration for CLUT access
- System-level control and monitoring
- Operation counting and performance metrics

**Arbitration Logic:**
- Round-robin scheduling ensures fairness
- Selected unit gets CLUT access each cycle
- Automatic response routing to requesting PE

**System Monitoring:**
- `operation_count`: Total completed operations
- `active_units`: Currently active MAC units
- `system_ready`: Overall system readiness

## Testing

### Testbench: `tb_lse_shared_system.sv`

Comprehensive test suite validating:

1. **Single MAC Operation**: Basic functionality test
2. **Parallel MAC Operations**: All units working simultaneously
3. **Sequential MAC Operations**: Resource sharing validation
4. **Bypass Mode**: Multiplier bypass testing
5. **System Stress Test**: Multiple iterations, high utilization

**Test Metrics:**
- Individual MAC result validation
- Timing and latency measurements
- CLUT arbitration verification
- System throughput analysis

### Running Tests

#### Option 1: Using ModelSim/QuestaSim

```powershell
# Prepare compilation list
.\scripts\compile_shared_system.ps1

# Compile with your simulator
vlib work
vlog -sv +define+DEBUG_SYSTEM modules\core\register.sv
vlog -sv +define+DEBUG_SYSTEM modules\core\lse_add.sv
vlog -sv +define+DEBUG_SYSTEM modules\lut\lse_clut_shared.sv
vlog -sv +define+DEBUG_SYSTEM modules\core\lse_pe_with_mux.sv
vlog -sv +define+DEBUG_SYSTEM modules\core\lse_log_mac.sv
vlog -sv +define+DEBUG_SYSTEM modules\lse_shared_system.sv
vlog -sv +define+DEBUG_SYSTEM testbenches\tb_lse_shared_system.sv

# Run simulation
vsim -t 1ps tb_lse_shared_system -do "run -all; quit"
```

#### Option 2: Using Automated Script

```powershell
.\scripts\test_shared_system.ps1 -Verbose
```

### Viewing Waveforms

Use the provided GTKWave configuration:

```powershell
.\scripts\test_shared_system.ps1 -WaveView
```

Configuration file: `gtkwave_configs\lse_shared_system.gtkw`

## Performance Characteristics

### Area Savings

**Traditional Architecture** (N PEs with separate CLUTs):
- CLUT instances: N × 16 entries × 10 bits = N × 160 bits
- Total: **160N bits of ROM**

**Shared Architecture** (N PEs with shared CLUT):
- CLUT instances: 1 × 16 entries × 10 bits = 160 bits
- Arbitration overhead: ~log₂(N) × N control bits
- Total: **~160 + log₂(N)×N bits**

**Savings**: ~(N-1) × 160 bits ≈ **85-90% ROM reduction** for N=4-8 PEs

### Throughput

- **Pipeline Depth**: 2-3 cycles per MAC operation
- **CLUT Access**: 1 cycle (pipelined)
- **Arbitration Overhead**: <1 cycle average with round-robin
- **Theoretical Throughput**: N operations / (2-3 cycles)

### Latency

- **MAC Operation**: 2-3 clock cycles
- **CLUT Arbitration**: 0-1 cycles (depends on contention)
- **Total Latency**: 3-5 clock cycles per operation

## Configuration Parameters

### System-Level Configuration

```systemverilog
lse_shared_system #(
    .NUM_MAC_UNITS(4),      // Number of MAC units
    .WIDTH(24),             // Data path width
    .FRAC_BITS(10),         // Fractional bits
    .CLUT_DEPTH(16),        // CLUT entries
    .PIPELINE_STAGES(2)     // Pipeline depth
) system_inst ( ... );
```

### Scaling Guidelines

| NUM_MAC_UNITS | Area Impact | Throughput | Recommended Use Case |
|---------------|-------------|------------|---------------------|
| 2             | Minimal     | 2x         | Low-power designs   |
| 4             | Low         | 4x         | Balanced (default)  |
| 8             | Moderate    | 8x         | High-performance    |
| 16+           | High        | 16x+       | Specialized HPC     |

## Debug Features

### Compile-Time Flags

- `+define+DEBUG_SYSTEM`: Enable system-level debug messages
- `+define+DEBUG_MAC`: Enable MAC-level debug messages
- `+define+ASSERTIONS_ON`: Enable SVA assertions

### Runtime Monitoring

```systemverilog
// System status signals
output logic system_ready          // System ready for operations
output logic [31:0] operation_count // Total operations completed
output logic [$clog2(NUM_MAC_UNITS)-1:0] active_units // Active units
```

### Waveform Analysis

Key signals to monitor:
1. **CLUT Arbitration**: `selected_unit`, `arb_valid`
2. **MAC Activity**: `mac_enable[i]`, `valid_array[i]`
3. **CLUT Interface**: `shared_clut_addr`, `shared_clut_correction`
4. **System Status**: `operation_count`, `system_ready`

## Integration Guide

### Adding to Existing Design

```systemverilog
// Instantiate shared system
lse_shared_system #(
    .NUM_MAC_UNITS(4)
) lse_system (
    .clk(clk),
    .rst_n(rst_n),
    .global_enable(enable),
    
    // Connect your MAC inputs
    .mac_enable(mac_en),
    .log_a_array(a_data),
    .log_b_array(b_data),
    .acc_array(acc_data),
    
    // Get MAC results
    .mac_results(results),
    .valid_array(valid),
    
    // Monitor system
    .system_ready(ready),
    .operation_count(ops)
);
```

### Control Flow

1. **Initialization**: Assert `rst_n`, set `global_enable`
2. **Load Accumulators**: Set `load_acc_array[i]` with initial values
3. **Start Operations**: Enable MAC units with `mac_enable[i]`
4. **Monitor Progress**: Check `valid_array[i]` for completion
5. **Read Results**: Capture `mac_results[i]` when `valid_array[i]` asserts

## References

Yao, Z., et al. (2024). "LSE-PE: Hardware Efficient for Tractable Probabilistic Reasoning." 
In *Proceedings of the Conference on Neural Information Processing Systems (NeurIPS)*.

Key contributions:
- Shared CLUT architecture for area efficiency
- Log-domain arithmetic for numerical stability
- Hardware-optimized LSE operations

## Future Enhancements

### Planned Features

1. **Dynamic Arbitration**: Priority-based scheduling
2. **CLUT Caching**: Local caches per PE for reduced contention
3. **Adaptive Pipeline**: Variable pipeline depth based on workload
4. **Power Gating**: Per-MAC power management

### Performance Optimizations

1. **CLUT Interpolation**: Linear interpolation between entries
2. **Predictive Prefetch**: Anticipate CLUT accesses
3. **Wider Data Paths**: Support for 32-bit or 48-bit operations
4. **Multiple CLUTs**: Bank multiple CLUTs for higher bandwidth

## Contact & Support

For questions, issues, or contributions, please refer to the project documentation.

**Version**: 1.0  
**Last Updated**: October 2025  
**Status**: ✅ Functional - Ready for Testing